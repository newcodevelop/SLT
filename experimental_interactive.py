# -*- coding: utf-8 -*-
"""Interactive SLT-1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Apa299V6TYxLYXjTMSHFBmV-VsXAjg_-

##### Copyright 2019 Dibyanayan Bandyopadhyay
"""

#@title Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.



#!pip install -q tfds-nightly


#!pip install matplotlib==3.2.2

#!pip install -q tqdm

#from google.colab import drive

#drive.mount('/content/gdrive', force_remount=True)
import os
os.environ["CUDA_DEVICE_ORDER"]="PCI_BUS_ID"
os.environ["CUDA_VISIBLE_DEVICES"]="0"

import tensorflow as tf
physical_devices = tf.config.experimental.list_physical_devices('GPU')
if len(physical_devices) > 0:
	for i in physical_devices:
		tf.config.experimental.set_memory_growth(i, True)
import time
import numpy as np
import matplotlib.pyplot as plt
import tensorflow as tf

# You'll generate plots of attention in order to see which parts of an image
# our model focuses on during captioning
import matplotlib.pyplot as plt

# Scikit-learn includes many helpful utilities
from sklearn.model_selection import train_test_split
from sklearn.utils import shuffle

import collections
import random
import re
import numpy as np
import os
import time
import json
from glob import glob
from PIL import Image
import pickle
from tqdm import tqdm
import glob
import shutil
import os
import argparse
import cv2
import argparse
import nltk.translate.bleu_score as bleu
import sacrebleu
my_parser = argparse.ArgumentParser()
my_parser.version = '1.0'

my_parser.add_argument('-BATCH_SIZE', action='store', type=int, required=True)
my_parser.add_argument('-BUFFER_SIZE', action='store', type=int, default=10)
my_parser.add_argument('-train_size', action='store', type=int, default=128)
my_parser.add_argument('-do_test_on_train', action='store', type=int, default=0)

my_parser.add_argument('-num_layers_enc', action='store', type=int, required=True)
my_parser.add_argument('-num_layers_dec', action='store', type=int, required=True)
my_parser.add_argument('-d_model', action='store', type=int, default=512)
my_parser.add_argument('-dff', action='store', type=int, default=512)
my_parser.add_argument('-num_heads', action='store', type=int, default=8)
my_parser.add_argument('-EPOCHS', action='store', type=int, required=True)

my_parser.add_argument('-train_dir', action='store', type=str, required=True)
my_parser.add_argument('-test_dir', action='store', type=str, required=True)
args = my_parser.parse_args()



BATCH_SIZE = args.BATCH_SIZE
BUFFER_SIZE = args.BUFFER_SIZE
train_size = args.train_size
num_layers_enc = args.num_layers_enc
num_layers_dec = args.num_layers_dec
d_model = args.d_model
dff = args.dff
num_heads = args.num_heads
EPOCHS = args.EPOCHS
dropout_rate = 0.1
do_test_on_train = args.do_test_on_train


import pickle
import gzip
def load_dataset_file(filename):
  with gzip.open(filename, "rb") as f:
    loaded_object = pickle.load(f)
    return loaded_object

p = load_dataset_file(args.train_dir)

videos,captions,glosses = [],[],[]
for i in range(len(p)):
  videos.append(np.asarray(p[i]['sign']))
  captions.append(p[i]['text'])
  glosses.append(p[i]['gloss'])

def get_tokenizer(arr,for_what='',start_token="",end_token=""):
    from tokenizers import Tokenizer
    from tokenizers.models import BPE

    tokenizer = Tokenizer(BPE())
    from tokenizers.trainers import BpeTrainer

    trainer = BpeTrainer(special_tokens=["[PAD]","[UNK]", "[CLS]", "[SEP]", "[MASK]", start_token, end_token])
    from tokenizers.pre_tokenizers import Whitespace

    tokenizer.pre_tokenizer = Whitespace()
    train_captions = [i+'\n' for i in arr]
    f1 = open('train_{}_dir.txt'.format(for_what), 'w')
    f1.writelines(train_captions)
    f1.close()
    tokenizer.train(trainer, [os.path.join(os.getcwd(),'train_{}_dir.txt'.format(for_what))])
    from tokenizers.processors import TemplateProcessing

    tokenizer.post_processor = TemplateProcessing(
        single="{} $A {}".format(start_token,end_token),
        special_tokens=[
            (start_token, tokenizer.token_to_id(start_token)),
            (end_token, tokenizer.token_to_id(end_token)),
        ],
    )
    tokenizer.enable_padding(pad_id=0, pad_token="[PAD]")

    o = tokenizer.encode_batch(arr)
    train_captions_final = np.asarray([i.ids for i in o],dtype = np.int32)
    return train_captions_final,tokenizer

train_captions_final,tokenizer = get_tokenizer(captions,'translation',"[TRANS-START]","[TRANS-END]") 
train_glosses_final,tokenizer_r = get_tokenizer(glosses,'recognition',"[RECOG-START]","[RECOG-END]") 
def create_padding_mask_image(videos):
  
  lens = []
  for i in videos:
	  lens.append(i.shape[0])
  m_len = max(lens)
  print(m_len)
  mask=[]
  for i in videos:
	  l = i.shape[0]
	  temp1 = [0 for _ in range(l)]
	  temp2 = [1 for _ in range(m_len-l)]
	  mask.append(temp1+temp2)
  mask = tf.cast(mask,tf.float32)
  print('done')
  #return mask[:, tf.newaxis, tf.newaxis, :]
  videos = tf.keras.preprocessing.sequence.pad_sequences(videos, padding='post', dtype = 'float32')
  return np.asarray(mask),videos
video_mask,videos = create_padding_mask_image(videos)

print(
  'DONE UPTO THIS'
)
masks = []
for vid in videos:
  mask = []
  for i in vid:
    #print(i)
    if (np.asarray(i)==np.zeros(len(i))).all():
      mask.append(1)
    else:
      mask.append(0)
  masks.append(mask)


assert (video_mask==masks).all()

videos = [i for i in videos]


for i,j in zip(train_captions_final,captions):
  assert tokenizer.decode(i)==j
"""
for i,j in zip(train_glosses_final,glosses):
  print((tokenizer_r.decode(i),j))
  assert tokenizer_r.decode(i)==j
"""
def map_func(img_name, cap,gloss,mask):
  #img_tensor = np.load(os.path.join(os.getcwd(),'processed_img',img_name.decode('utf-8').split('/')[-1]+'_constructed'+'.npy'))
  
  return img_name, cap,gloss,mask


def tf_encode(img, cap,gloss,mask):
  result_pt, result_en, result_en1,mask = tf.numpy_function(map_func, [img, cap,gloss,mask], [tf.float32, tf.int32, tf.int32,tf.float32])
  result_en.set_shape([None])
  result_en1.set_shape([None])
  result_pt.set_shape([None,None])
  mask.set_shape([None])
  return result_pt, result_en, result_en1,mask

dataset = tf.data.Dataset.from_tensor_slices((videos, train_captions_final,train_glosses_final,video_mask))

# Use map to load the numpy files in parallel
dataset = dataset.map(tf_encode)

# Shuffle and batch


dataset = dataset.shuffle(BUFFER_SIZE).padded_batch(BATCH_SIZE,([None,None],[None],[None],[None]))



print('dataset created')





def get_angles(pos, i, d_model):
  angle_rates = 1 / np.power(10000, (2 * (i//2)) / np.float32(d_model))
  return pos * angle_rates

def positional_encoding(position, d_model):
  angle_rads = get_angles(np.arange(position)[:, np.newaxis],
                          np.arange(d_model)[np.newaxis, :],
                          d_model)
  
  # apply sin to even indices in the array; 2i
  angle_rads[:, 0::2] = np.sin(angle_rads[:, 0::2])
  
  # apply cos to odd indices in the array; 2i+1
  angle_rads[:, 1::2] = np.cos(angle_rads[:, 1::2])
    
  pos_encoding = angle_rads[np.newaxis, ...]
    
  return tf.cast(pos_encoding, dtype=tf.float32)



input_vocab_size = tokenizer.get_vocab_size()  # useless for image
target_vocab_size_recog = tokenizer_r.get_vocab_size() 
target_vocab_size_trans = tokenizer.get_vocab_size() 

"""## Masking

Mask all the pad tokens in the batch of sequence. It ensures that the model does not treat padding as the input. The mask indicates where pad value `0` is present: it outputs a `1` at those locations, and a `0` otherwise.
"""

def create_padding_mask_text(seq):
  seq = tf.cast(tf.math.equal(seq, 0), tf.float32)
  
  # add extra dimensions to add the padding
  # to the attention logits.
  return seq[:, tf.newaxis, tf.newaxis, :]  # (batch_size, 1, 1, seq_len)

"""The look-ahead mask is used to mask the future tokens in a sequence. In other words, the mask indicates which entries should not be used.

This means that to predict the third word, only the first and second word will be used. Similarly to predict the fourth word, only the first, second and the third word will be used and so on.
"""

def create_look_ahead_mask(size):
  mask = 1 - tf.linalg.band_part(tf.ones((size, size)), -1, 0)
  return mask  # (seq_len, seq_len)


def scaled_dot_product_attention(q, k, v, mask):
  """Calculate the attention weights.
  q, k, v must have matching leading dimensions.
  k, v must have matching penultimate dimension, i.e.: seq_len_k = seq_len_v.
  The mask has different shapes depending on its type(padding or look ahead) 
  but it must be broadcastable for addition.
  
  Args:
    q: query shape == (..., seq_len_q, depth)
    k: key shape == (..., seq_len_k, depth)
    v: value shape == (..., seq_len_v, depth_v)
    mask: Float tensor with shape broadcastable 
          to (..., seq_len_q, seq_len_k). Defaults to None.
    
  Returns:
    output, attention_weights
  """

  matmul_qk = tf.matmul(q, k, transpose_b=True)  # (..., seq_len_q, seq_len_k)
  
  # scale matmul_qk
  dk = tf.cast(tf.shape(k)[-1], tf.float32)
  scaled_attention_logits = matmul_qk / tf.math.sqrt(dk)

  # add the mask to the scaled tensor.
  if mask is not None:
    scaled_attention_logits += (mask * -1e9)  

  # softmax is normalized on the last axis (seq_len_k) so that the scores
  # add up to 1.
  attention_weights = tf.nn.softmax(scaled_attention_logits, axis=-1)  # (..., seq_len_q, seq_len_k)

  output = tf.matmul(attention_weights, v)  # (..., seq_len_q, depth_v)

  return output, attention_weights



class MultiHeadAttention(tf.keras.layers.Layer):
  def __init__(self, d_model, num_heads):
    super(MultiHeadAttention, self).__init__()
    self.num_heads = num_heads
    self.d_model = d_model
    
    assert d_model % self.num_heads == 0
    
    self.depth = d_model // self.num_heads
    
    self.wq = tf.keras.layers.Dense(d_model)
    self.wk = tf.keras.layers.Dense(d_model)
    self.wv = tf.keras.layers.Dense(d_model)
    
    self.dense = tf.keras.layers.Dense(d_model)
        
  def split_heads(self, x, batch_size):
    """Split the last dimension into (num_heads, depth).
    Transpose the result such that the shape is (batch_size, num_heads, seq_len, depth)
    """
    x = tf.reshape(x, (batch_size, -1, self.num_heads, self.depth))
    return tf.transpose(x, perm=[0, 2, 1, 3])
    
  def call(self, v, k, q, mask):
    batch_size = tf.shape(q)[0]
    
    q = self.wq(q)  # (batch_size, seq_len, d_model)
    k = self.wk(k)  # (batch_size, seq_len, d_model)
    v = self.wv(v)  # (batch_size, seq_len, d_model)
    
    q = self.split_heads(q, batch_size)  # (batch_size, num_heads, seq_len_q, depth)
    k = self.split_heads(k, batch_size)  # (batch_size, num_heads, seq_len_k, depth)
    v = self.split_heads(v, batch_size)  # (batch_size, num_heads, seq_len_v, depth)
    
    # scaled_attention.shape == (batch_size, num_heads, seq_len_q, depth)
    # attention_weights.shape == (batch_size, num_heads, seq_len_q, seq_len_k)
    scaled_attention, attention_weights = scaled_dot_product_attention(
        q, k, v, mask)
    
    scaled_attention = tf.transpose(scaled_attention, perm=[0, 2, 1, 3])  # (batch_size, seq_len_q, num_heads, depth)

    concat_attention = tf.reshape(scaled_attention, 
                                  (batch_size, -1, self.d_model))  # (batch_size, seq_len_q, d_model)

    output = self.dense(concat_attention)  # (batch_size, seq_len_q, d_model)
        
    return output, attention_weights


def point_wise_feed_forward_network(d_model, dff):
  return tf.keras.Sequential([
      tf.keras.layers.Dense(dff, activation='relu'),  # (batch_size, seq_len, dff)
      tf.keras.layers.Dense(d_model)  # (batch_size, seq_len, d_model)
  ])



class EncoderLayer(tf.keras.layers.Layer):
  def __init__(self, d_model, num_heads, dff, rate=0.1):
    super(EncoderLayer, self).__init__()

    self.mha = MultiHeadAttention(d_model, num_heads)
    self.ffn = point_wise_feed_forward_network(d_model, dff)

    self.layernorm1 = tf.keras.layers.LayerNormalization(epsilon=1e-6)
    self.layernorm2 = tf.keras.layers.LayerNormalization(epsilon=1e-6)
    
    self.dropout1 = tf.keras.layers.Dropout(rate)
    self.dropout2 = tf.keras.layers.Dropout(rate)
    
  def call(self, x, training, mask):

    attn_output, _ = self.mha(x, x, x, mask)  # (batch_size, input_seq_len, d_model)
    attn_output = self.dropout1(attn_output, training=training)
    out1 = self.layernorm1(x + attn_output)  # (batch_size, input_seq_len, d_model)
    
    ffn_output = self.ffn(out1)  # (batch_size, input_seq_len, d_model)
    ffn_output = self.dropout2(ffn_output, training=training)
    out2 = self.layernorm2(out1 + ffn_output)  # (batch_size, input_seq_len, d_model)
    
    return out2



class DecoderLayer(tf.keras.layers.Layer):
  def __init__(self, d_model, num_heads, dff, rate=0.1):
    super(DecoderLayer, self).__init__()

    self.mha1 = MultiHeadAttention(d_model, num_heads)
    self.mha2 = MultiHeadAttention(d_model, num_heads)
    self.mha3 = MultiHeadAttention(d_model, num_heads)
    self.ffn = point_wise_feed_forward_network(d_model, dff)
 
    self.layernorm1 = tf.keras.layers.LayerNormalization(epsilon=1e-6)
    self.layernorm2 = tf.keras.layers.LayerNormalization(epsilon=1e-6)
    self.layernorm3 = tf.keras.layers.LayerNormalization(epsilon=1e-6)
    self.layernorm4 = tf.keras.layers.LayerNormalization(epsilon=1e-6)
    
    
    self.dropout1 = tf.keras.layers.Dropout(rate)
    self.dropout2 = tf.keras.layers.Dropout(rate)
    self.dropout3 = tf.keras.layers.Dropout(rate)
    self.dropout4 = tf.keras.layers.Dropout(rate)
    
    
  def call(self, x, enc_output, interactive_input, training, 
           look_ahead_mask, padding_mask,special_mask):
    # enc_output.shape == (batch_size, input_seq_len, d_model)

    self_attention, _ = self.mha1(x, x, x, look_ahead_mask)  # (batch_size, target_seq_len, d_model)
    self_attention = self.dropout1(self_attention, training=training)
    self_attention = self.layernorm1(self_attention + x)
    
    cross_attention, _ = self.mha2(
        interactive_input, interactive_input, x, special_mask)  # (batch_size, target_seq_len, d_model)
    cross_attention = self.dropout2(cross_attention, training=training)
    cross_attention = self.layernorm2(cross_attention + x)

    fused_attention = self_attention+0.5*cross_attention
    attn2, _ = self.mha3(
        enc_output, enc_output, fused_attention, padding_mask)  # (batch_size, target_seq_len, d_model)
    attn2 = self.dropout3(attn2, training=training)
    out2 = self.layernorm3(attn2 + fused_attention)  # (batch_size, target_seq_len, d_model)
    
    ffn_output = self.ffn(out2)  # (batch_size, target_seq_len, d_model)
    ffn_output = self.dropout4(ffn_output, training=training)
    out3 = self.layernorm4(ffn_output + out2)  # (batch_size, target_seq_len, d_model)
    
    return out3, None, None



"""### Encoder

The `Encoder` consists of:
1.   Input Embedding
2.   Positional Encoding
3.   N encoder layers

The input is put through an embedding which is summed with the positional encoding. The output of this summation is the input to the encoder layers. The output of the encoder is the input to the decoder.
"""

class Encoder(tf.keras.layers.Layer):
  def __init__(self, num_layers, d_model, num_heads, dff, input_vocab_size,
               maximum_position_encoding, rate=0.1):
    super(Encoder, self).__init__()

    self.d_model = d_model
    self.num_layers = num_layers
    
    #self.embedding = tf.keras.layers.Embedding(input_vocab_size, d_model)
    self.embedding = tf.keras.layers.Dense(d_model)
    self.pos_encoding = positional_encoding(maximum_position_encoding, 
                                            self.d_model)
    
    
    self.enc_layers = [EncoderLayer(d_model, num_heads, dff, rate) 
                       for _ in range(num_layers)]
  
    self.dropout = tf.keras.layers.Dropout(rate)
        
  def call(self, x, training, mask):

    seq_len = tf.shape(x)[1]
    
    # adding embedding and position encoding.
    x = self.embedding(x)  # (batch_size, input_seq_len, d_model)
    
    
    #print(np.shape(x))
    #x *= tf.math.sqrt(tf.cast(self.d_model, tf.float32))
    x += self.pos_encoding[:, :seq_len, :]

    x = self.dropout(x, training=training)
    
    for i in range(self.num_layers):
      x = self.enc_layers[i](x, training, mask)
    
    return x  # (batch_size, input_seq_len, d_model)

"""### Decoder

The `Decoder` consists of:
1.   Output Embedding
2.   Positional Encoding
3.   N decoder layers

The target is put through an embedding which is summed with the positional encoding. The output of this summation is the input to the decoder layers. The output of the decoder is the input to the final linear layer.
"""

class Decoder(tf.keras.layers.Layer):
  def __init__(self, num_layers, d_model, num_heads, dff, target_vocab_size_recog, target_vocab_size_trans,
               maximum_position_encoding_recog,maximum_position_encoding_trans, rate=0.1):
    super(Decoder, self).__init__()

    self.d_model = d_model
    self.num_layers = num_layers
    
    self.embedding_recog = tf.keras.layers.Embedding(target_vocab_size_recog, d_model)
    self.pos_encoding_recog = positional_encoding(maximum_position_encoding_recog, d_model)

    self.embedding_trans = tf.keras.layers.Embedding(target_vocab_size_trans, d_model)
    self.pos_encoding_trans = positional_encoding(maximum_position_encoding_trans, d_model)
    
    self.dec_layers = [DecoderLayer(d_model, num_heads, dff, rate) 
                       for _ in range(num_layers)]
    self.dropout1 = tf.keras.layers.Dropout(rate)
    self.dropout2 = tf.keras.layers.Dropout(rate)
    
  def call(self, x, enc_output, interactive_input, training, 
           look_ahead_mask, padding_mask, special_mask,type = 'trans'):

    
    attention_weights = {}
    
    if type=='recog':
      seq_len_x = tf.shape(x)[1]
      x = self.embedding_recog(x)  # (batch_size, target_seq_len, d_model)
      x *= tf.math.sqrt(tf.cast(self.d_model, tf.float32))
      x += self.pos_encoding_recog[:, :seq_len_x, :]
      
      x = self.dropout1(x, training=training)


      seq_len_interactive = tf.shape(interactive_input)[1]
      interactive_input = self.embedding_trans(interactive_input)  # (batch_size, target_seq_len, d_model)
      interactive_input *= tf.math.sqrt(tf.cast(self.d_model, tf.float32))
      interactive_input += self.pos_encoding_trans[:, :seq_len_interactive, :]
      
      interactive_input = self.dropout2(interactive_input, training=training)

    elif type=='trans':
      seq_len_x = tf.shape(x)[1]
      x = self.embedding_trans(x)  # (batch_size, target_seq_len, d_model)
      x *= tf.math.sqrt(tf.cast(self.d_model, tf.float32))
      x += self.pos_encoding_trans[:, :seq_len_x, :]
      
      x = self.dropout1(x, training=training)


      seq_len_interactive = tf.shape(interactive_input)[1]
      interactive_input = self.embedding_recog(interactive_input)  # (batch_size, target_seq_len, d_model)
      interactive_input *= tf.math.sqrt(tf.cast(self.d_model, tf.float32))
      interactive_input += self.pos_encoding_recog[:, :seq_len_interactive, :]
      
      interactive_input = self.dropout2(interactive_input, training=training)


    for i in range(self.num_layers):
      x, block1, block2 = self.dec_layers[i](x, enc_output, interactive_input, training,
                                             look_ahead_mask, padding_mask,special_mask)
      
      attention_weights['decoder_layer{}_block1'.format(i+1)] = block1
      attention_weights['decoder_layer{}_block2'.format(i+1)] = block2
    
    # x.shape == (batch_size, target_seq_len, d_model)
    return x, attention_weights




"""## Create the Transformer

Transformer consists of the encoder, decoder and a final linear layer. The output of the decoder is the input to the linear layer and its output is returned.
"""

class Transformer(tf.keras.Model):
  def __init__(self, num_layers_enc,num_layers_dec, d_model, num_heads, dff, input_vocab_size, 
               target_vocab_size_recog,target_vocab_size_trans, pe_input, pe_target_recog,pe_target_trans, rate=0.1):
    super(Transformer, self).__init__()

    self.encoder = Encoder(num_layers_enc, d_model, num_heads, dff, 
                           input_vocab_size, pe_input, rate)

    self.decoder1 = Decoder(num_layers_dec, d_model, num_heads, dff, 
                           target_vocab_size_recog,target_vocab_size_trans, pe_target_recog,pe_target_trans, rate)
                      
    self.decoder2 = Decoder(num_layers_dec, d_model, num_heads, dff, 
                           target_vocab_size_recog,target_vocab_size_trans, pe_target_recog,pe_target_trans, rate)

    self.final_layer1 = tf.keras.layers.Dense(target_vocab_size_recog)
    self.final_layer2 = tf.keras.layers.Dense(target_vocab_size_trans)
  def call(self, inp, tar1,tar2, training, enc_padding_mask, 
           look_ahead_mask_recog, dec_padding_mask_recog, look_ahead_mask_trans, dec_padding_mask_trans, special_mask_recog, special_mask_trans):

    enc_output = self.encoder(inp, training, enc_padding_mask)  # (batch_size, inp_seq_len, d_model)
    
    # dec_output.shape == (batch_size, tar_seq_len, d_model)
    dec_output1, attention_weights1 = self.decoder1(
        tar1, enc_output, tar2, training, look_ahead_mask_recog, dec_padding_mask_recog,special_mask_trans,type='recog')

    dec_output2, attention_weights2 = self.decoder2(
        tar2, enc_output, tar1, training, look_ahead_mask_trans, dec_padding_mask_trans,special_mask_recog,type='trans')
    
    final_output1 = self.final_layer1(dec_output1)  # (batch_size, tar_seq_len, target_vocab_size)
    final_output2 = self.final_layer2(dec_output2)
    return final_output1, final_output2, None

"""## Set hyperparameters

To keep this example small and relatively fast, the values for *num_layers, d_model, and dff* have been reduced. 

The values used in the base model of transformer were; *num_layers=6*, *d_model = 512*, *dff = 2048*. See the [paper](https://arxiv.org/abs/1706.03762) for all the other versions of the transformer.

Note: By changing the values below, you can get the model that achieved state of the art on many tasks.
"""



"""## Optimizer

Use the Adam optimizer with a custom learning rate scheduler according to the formula in the [paper](https://arxiv.org/abs/1706.03762).

$$\Large{lrate = d_{model}^{-0.5} * min(step{\_}num^{-0.5}, step{\_}num * warmup{\_}steps^{-1.5})}$$
"""

class CustomSchedule(tf.keras.optimizers.schedules.LearningRateSchedule):
  def __init__(self, d_model, warmup_steps=4000):
    super(CustomSchedule, self).__init__()
    
    self.d_model = d_model
    self.d_model = tf.cast(self.d_model, tf.float32)

    self.warmup_steps = warmup_steps
    
  def __call__(self, step):
    arg1 = tf.math.rsqrt(step)
    arg2 = step * (self.warmup_steps ** -1.5)
    
    return tf.math.rsqrt(self.d_model) * tf.math.minimum(arg1, arg2)

learning_rate = CustomSchedule(d_model)
"""
optimizer = tf.keras.optimizers.Adam(learning_rate, beta_1=0.9, beta_2=0.98, 
                                     epsilon=1e-9)
"""
optimizer = tf.keras.optimizers.Adam(learning_rate, beta_1=0.9, beta_2=0.98, 
                                     epsilon=1e-9)

"""## Loss and metrics

Since the target sequences are padded, it is important to apply a padding mask when calculating the loss.
"""

loss_object = tf.keras.losses.SparseCategoricalCrossentropy(
    from_logits=True, reduction='none')

def loss_function(real, pred):
  #print('real {}'.format(tf.print(real)))
  #print('pred {}'.format(tf.print(tf.argmax(pred,axis = -1))))
  mask = tf.math.logical_not(tf.math.equal(real, 0))
  loss_ = loss_object(real, pred)

  mask = tf.cast(mask, dtype=loss_.dtype)
  loss_ *= mask
  
  return tf.reduce_sum(loss_)/tf.reduce_sum(mask)

train_loss = tf.keras.metrics.Mean(name='train_loss')
train_accuracy = tf.keras.metrics.SparseCategoricalAccuracy(
    name='train_accuracy')

"""## Training and checkpointing"""



transformer = Transformer(num_layers_enc,num_layers_dec, d_model, num_heads, dff,
                          input_vocab_size, target_vocab_size_recog, target_vocab_size_trans,
                          pe_input=input_vocab_size, 
                          pe_target_recog=target_vocab_size_recog,
                          pe_target_trans=target_vocab_size_trans,
                          rate=dropout_rate)
"""
def create_masks(inp, tar):
  # Encoder padding mask
  if inp==None:
    enc_padding_mask = None
    dec_padding_mask = None
    look_ahead_mask = create_look_ahead_mask(tf.shape(tar)[1])
    dec_target_padding_mask = create_padding_mask(tar)
    combined_mask = tf.maximum(dec_target_padding_mask, look_ahead_mask)
  else:
    enc_padding_mask = create_padding_mask(inp)
    
    # Used in the 2nd attention block in the decoder.
    # This padding mask is used to mask the encoder outputs.
    dec_padding_mask = create_padding_mask(inp)
    
    # Used in the 1st attention block in the decoder.
    # It is used to pad and mask future tokens in the input received by 
    # the decoder.
    look_ahead_mask = create_look_ahead_mask(tf.shape(tar)[1])
    dec_target_padding_mask = create_padding_mask(tar)
    combined_mask = tf.maximum(dec_target_padding_mask, look_ahead_mask)
  
  return enc_padding_mask, combined_mask, dec_padding_mask
"""

def create_masks(tar):
  # Encoder padding mask
 
  #enc_padding_mask = create_padding_mask_image(inp)
  
  # Used in the 2nd attention block in the decoder.
  # This padding mask is used to mask the encoder outputs.
  #dec_padding_mask = create_padding_mask_image(inp)
  
  # Used in the 1st attention block in the decoder.
  # It is used to pad and mask future tokens in the input received by 
  # the decoder.
  look_ahead_mask = create_look_ahead_mask(tf.shape(tar)[1])
  dec_target_padding_mask = create_padding_mask_text(tar)
  #tf.print(tf.shape(look_ahead_mask))
  #tf.print(tf.shape(dec_target_padding_mask))
  combined_mask = tf.maximum(dec_target_padding_mask, look_ahead_mask)
  #tf.print(tf.shape(combined_mask))
  return combined_mask
def create_special_mask(a,b):
  look_ahead_mask = 1 - tf.linalg.band_part(tf.ones((tf.shape(a)[1], tf.shape(b)[1])), -1, 0) #(53,35) a = (28,53), b = (28,35)
  dec_target_padding_mask = create_padding_mask_text(b) # (28,1,1,35)
  combined_mask = tf.maximum(dec_target_padding_mask, look_ahead_mask) # (28,1,53,35)
  #for special_mask_recog a = trans, b = recog
  return combined_mask

"""Create the checkpoint path and the checkpoint manager. This will be used to save checkpoints every `n` epochs."""

checkpoint_path = "./checkpoints/train/interactive"

ckpt = tf.train.Checkpoint(transformer=transformer,
                           optimizer=optimizer)

ckpt_manager = tf.train.CheckpointManager(ckpt, checkpoint_path, max_to_keep=5)

# if a checkpoint exists, restore the latest checkpoint.
if ckpt_manager.latest_checkpoint:
  ckpt.restore(ckpt_manager.latest_checkpoint)
  print ('Latest checkpoint restored!!')

"""The target is divided into tar_inp and tar_real. tar_inp is passed as an input to the decoder. `tar_real` is that same input shifted by 1: At each location in `tar_input`, `tar_real` contains the  next token that should be predicted.

For example, `sentence` = "SOS A lion in the jungle is sleeping EOS"

`tar_inp` =  "SOS A lion in the jungle is sleeping"

`tar_real` = "A lion in the jungle is sleeping EOS"

The transformer is an auto-regressive model: it makes predictions one part at a time, and uses its output so far to decide what to do next. 

During training this example uses teacher-forcing (like in the [text generation tutorial](./text_generation.ipynb)). Teacher forcing is passing the true output to the next time step regardless of what the model predicts at the current time step.

As the transformer predicts each word, *self-attention* allows it to look at the previous words in the input sequence to better predict the next word.

To prevent the model from peeking at the expected output the model uses a look-ahead mask.
"""

m_len = 475
k = 1024

# The @tf.function trace-compiles train_step into a TF graph for faster
# execution. The function specializes to the precise shape of the argument
# tensors. To avoid re-tracing due to the variable sequence lengths or variable
# batch sizes (the last batch is smaller), use input_signature to specify
# more generic shapes.

train_step_signature = [
    tf.TensorSpec(shape=(None,m_len,k), dtype=tf.float32),
    tf.TensorSpec(shape=(None,None), dtype=tf.int32),
    tf.TensorSpec(shape=(None,None), dtype=tf.int32),
    tf.TensorSpec(shape=(None,None), dtype=tf.float32)
]

@tf.function(input_signature=train_step_signature)
def train_step(inp, tar1,tar2,mask):
  tar_inp1 = tar1[:, :-1]
  tar_real1 = tar1[:, 1:]
  tar_inp2 = tar2[:, :-1]
  tar_real2 = tar2[:, 1:]
  """
  enc_padding_mask, combined_mask_recog, dec_padding_mask_recog = create_masks(None, tar_inp1)
  _, combined_mask_trans, dec_padding_mask_trans = create_masks(None, tar_inp2)
  """
  #special_mask_recog=create_padding_mask_text(tar_inp1)
  #special_mask_trans=create_padding_mask_text(tar_inp2)
  special_mask_recog=create_special_mask(tar_inp2,tar_inp1)
  special_mask_trans=create_special_mask(tar_inp1,tar_inp2)
  combined_mask_recog = create_masks(tar_inp1)
  combined_mask_trans = create_masks(tar_inp2)
  enc_padding_mask = mask[:,tf.newaxis,tf.newaxis,:]
  dec_padding_mask_recog,dec_padding_mask_trans = mask[:,tf.newaxis,tf.newaxis,:],mask[:,tf.newaxis,tf.newaxis,:]
  with tf.GradientTape() as tape:
    predictions1,predictions2, _ = transformer(inp, tar_inp1, tar_inp2,
                                 True, 
                                 enc_padding_mask, 
                                 combined_mask_recog, 
                                 dec_padding_mask_recog,
                                 combined_mask_trans, 
                                 dec_padding_mask_trans,special_mask_recog,special_mask_trans)
    loss1 = loss_function(tar_real1, predictions1)
    loss2 = loss_function(tar_real2, predictions2)
    loss = loss1+loss2
  gradients = tape.gradient(loss, transformer.trainable_variables)    
  optimizer.apply_gradients(zip(gradients, transformer.trainable_variables))
  
  train_loss(loss)
  train_accuracy(tar_real2, predictions2)






def evaluate(video_test):
  final_feature = np.asarray(video_test,dtype= np.float32)
  
  encoder_input = tf.reshape(final_feature,(-1,1024))[tf.newaxis,:,:]
  print('Encoder input in evaluation {}'.format(tf.shape(encoder_input)))
  
  decoder_input_trans = [tokenizer.token_to_id("[TRANS-START]")]
  #decoder_input_trans = [121]
  decoder_input_recog = [tokenizer_r.token_to_id("[RECOG-START]")]
  output_trans = tf.expand_dims(decoder_input_trans, 0)
  output_recog = tf.expand_dims(decoder_input_recog, 0)
  
  enc_padding_mask,dec_padding_mask_recog,dec_padding_mask_trans = None,None,None
  MAX_LENGTH = 28
  for i in range(MAX_LENGTH):
    combined_mask_recog = create_masks(output_recog)
    combined_mask_trans = create_masks(output_trans)
    special_mask_recog=create_special_mask(output_trans,output_recog)
    special_mask_trans=create_special_mask(output_recog,output_trans)
    # predictions.shape == (batch_size, seq_len, vocab_size)
   
    predictions1,predictions2, _ = transformer(encoder_input, output_recog, output_trans,
                                 False, 
                                 enc_padding_mask, 
                                 combined_mask_recog, 
                                 dec_padding_mask_recog,
                                 combined_mask_trans, 
                                 dec_padding_mask_trans,special_mask_recog,special_mask_trans)
    
    """
    predictions1,predictions2, _ = transformer(encoder_input, output_recog, output_trans,
                                 False, 
                                 None, 
                                 combined_mask_recog, 
                                 None,
                                 combined_mask_trans, 
                                 None,None,None)
                                 
    """
    predictions_recog = predictions1[: ,-1:, :]  # (batch_size, 1, vocab_size)

    predicted_id_recog = tf.cast(tf.argmax(predictions_recog, axis=-1), tf.int32)

    output_recog = tf.concat([output_recog, predicted_id_recog], axis=-1)

    predictions_trans = predictions2[: ,-1:, :]  # (batch_size, 1, vocab_size)

    predicted_id_trans = tf.cast(tf.argmax(predictions_trans, axis=-1), tf.int32)
    
    
    if predicted_id_trans == tokenizer.token_to_id("[TRANS-END]"):
      print('YES')	
      return tf.squeeze(output_trans, axis=0), None
    
    
    output_trans = tf.concat([output_trans, predicted_id_trans], axis=-1)
    #print(tf.squeeze(output_trans,axis=0))

  return tf.squeeze(output_trans, axis=0), None




def evaluate_beam(video_test,bl):
  final_feature = np.asarray(video_test,dtype= np.float32)
  
  encoder_input = tf.reshape(final_feature,(-1,1024))[tf.newaxis,:,:]
  
  #decoder_input = [tokenizer.token_to_id("[TRANS-START]")]
  #output = tf.expand_dims(decoder_input, 0)

  decoder_input_trans = [tokenizer.token_to_id("[TRANS-START]")]
  #decoder_input_trans = [121]
  decoder_input_recog = [tokenizer_r.token_to_id("[RECOG-START]")]
  output_trans = tf.expand_dims(decoder_input_trans, 0)
  output_recog = tf.expand_dims(decoder_input_recog, 0)
  
  enc_padding_mask,dec_padding_mask_recog,dec_padding_mask_trans = None,None,None



  enc_padding_mask,dec_padding_mask = None,None
  combined_mask_recog = create_masks(output_recog)
  combined_mask_trans = create_masks(output_trans)
  special_mask_recog=create_special_mask(output_trans,output_recog)
  special_mask_trans=create_special_mask(output_recog,output_trans)
    
   
  predictions1,predictions2, _ = transformer(encoder_input, output_recog, output_trans,
                                 False, 
                                 enc_padding_mask, 
                                 combined_mask_recog, 
                                 dec_padding_mask_recog,
                                 combined_mask_trans, 
                                 dec_padding_mask_trans,special_mask_recog,special_mask_trans)
  
  MAX_LENGTH = 16
 
  predictions_recog = predictions1[: ,-1:, :]  # (batch_size, 1, vocab_size)
  
  predicted_ids_recog = tf.cast(tf.argsort(predictions_recog,axis = -1, direction='DESCENDING'),tf.int32)[:,:,0:bl]
  predicted_ids_recog = tf.squeeze(predicted_ids_recog)
  predicted_prob_recog = tf.cast(tf.sort(predictions1, axis=-1,direction='DESCENDING'), tf.float32)[:,:,0:bl] #[-.7,-.9]
  predicted_prob_recog = tf.squeeze(predicted_prob_recog)
  outputs_recog = tf.stack([tf.concat([output_recog,[[i]]],axis = -1) for i in predicted_ids_recog])

  predictions_trans = predictions2[: ,-1:, :]  # (batch_size, 1, vocab_size)
  
  predicted_ids_trans = tf.cast(tf.argsort(predictions_trans,axis = -1, direction='DESCENDING'),tf.int32)[:,:,0:bl]
  predicted_ids_trans = tf.squeeze(predicted_ids_trans)
  predicted_prob_trans = tf.cast(tf.sort(predictions2, axis=-1,direction='DESCENDING'), tf.float32)[:,:,0:bl] #[-.7,-.9]
  predicted_prob_trans = tf.squeeze(predicted_prob_trans)
  outputs_trans = tf.stack([tf.concat([output_trans,[[i]]],axis = -1) for i in predicted_ids_trans])
  
 
  for _ in range(MAX_LENGTH):
    temp1,temp2,temp3,temp4 = [],[],[],[]
    for i,j,k,l in zip(outputs_recog,predicted_prob_recog,outputs_trans,predicted_prob_trans):
      combined_mask_recog = create_masks(i)
      combined_mask_trans = create_masks(k)
      special_mask_recog=create_special_mask(k,i)
      special_mask_trans=create_special_mask(i,k)
      predictions1,predictions2, _ = transformer(encoder_input, i, k,
                                 False, 
                                 enc_padding_mask, 
                                 combined_mask_recog, 
                                 dec_padding_mask_recog,
                                 combined_mask_trans, 
                                 dec_padding_mask_trans,special_mask_recog,special_mask_trans)

      # select the last word from the seq_len dimension
      predictions1 = predictions1[: ,-1:, :]  

      predicted_ids1 = tf.cast(tf.argsort(predictions1,axis = -1, direction='DESCENDING'),tf.int32)[:,:,0:bl]
      predicted_ids1 = tf.squeeze(predicted_ids1)

      temp1.append(tf.stack([tf.concat([i,[[x]]],axis = -1) for x in predicted_ids1]))
      
      predicted_prob1 = tf.cast(tf.sort(predictions1, axis=-1,direction='DESCENDING'), tf.float32)[:,:,0:bl]
      predicted_prob1 = tf.squeeze(predicted_prob1) 
      temp2 += [j+y for y in predicted_prob1]


      predictions2 = predictions2[: ,-1:, :]  

      predicted_ids2 = tf.cast(tf.argsort(predictions2,axis = -1, direction='DESCENDING'),tf.int32)[:,:,0:bl]
      predicted_ids2 = tf.squeeze(predicted_ids2)

      temp3.append(tf.stack([tf.concat([k,[[x]]],axis = -1) for x in predicted_ids2]))
      
      predicted_prob2 = tf.cast(tf.sort(predictions2, axis=-1,direction='DESCENDING'), tf.float32)[:,:,0:bl]
      predicted_prob2 = tf.squeeze(predicted_prob2) 
      temp4 += [l+y for y in predicted_prob2] 
    
    idx1 = np.argsort(temp2)
    idx1 = list(reversed(idx1))[0:bl]
    
    t1,t2 = [],[]
    temp1 = tf.concat([i for i in temp1],axis=0)
    
    for i in idx1:
      t1.append(temp1[i])
      t2.append(temp2[i])

    
    outputs_recog = tf.stack([i for i in t1])
    predicted_prob_recog = t2
    #********************************************
    idx2 = np.argsort(temp4)
    idx2 = list(reversed(idx2))[0:bl]
    
    t3,t4 = [],[]
    temp3 = tf.concat([i for i in temp3],axis=0)
    
    for i in idx2:
      t3.append(temp3[i])
      t4.append(temp4[i])

    
    outputs_trans = tf.stack([i for i in t3])
    predicted_prob_trans = t4
    

  o = tf.squeeze(outputs_trans[0,:,:])
  return o, None







def translate(img,plot=''):
  result, attention_weights = evaluate(img)
  result_beam1,_ = evaluate_beam(img,2)
  result_beam2,_ = evaluate_beam(img,3)
  predicted_sentence1 = tokenizer.decode([i for i in result])
  predicted_sentence2 = tokenizer.decode([i for i in result_beam1])
  predicted_sentence3 = tokenizer.decode([i for i in result_beam2])

  print('Predicted translation: {}'.format(str(predicted_sentence1)))
  print('Predicted translation for bl 2: {}'.format(str(predicted_sentence2)))
  print('Predicted translation for bl 3: {}'.format(str(predicted_sentence3)))
  return predicted_sentence1,predicted_sentence2,predicted_sentence3
  
 
p1 = load_dataset_file(args.test_dir)

videos_test,captions_test,glosses_test = [],[],[]
for i in range(len(p1)):
  videos_test.append(np.asarray(p1[i]['sign']))
  captions_test.append(p1[i]['text'])
  glosses_test.append(p1[i]['gloss'])






if __name__== "__main__":
  for epoch in range(EPOCHS):
    start = time.time()
    
    train_loss.reset_states()
    train_accuracy.reset_states()
    
    # inp -> portuguese, tar -> english
    for (batch, (inp, tar1,tar2,mask)) in tqdm(enumerate(dataset)):
      if epoch==0 and batch==0:
      	print(tar1)
      	print(tar2)
      train_step(inp, tar2,tar1,mask)
      
      if batch % 50 == 0:
        print ('Epoch {} Batch {} Loss {:.4f} Accuracy {:.4f}'.format(
      epoch + 1, batch, train_loss.result(), train_accuracy.result()))
        
    if (epoch + 1) % 5 == 0:
      ckpt_save_path = ckpt_manager.save()
      print ('Saving checkpoint for epoch {} at {}'.format(epoch+1,
                                                     ckpt_save_path))
      
    print ('Epoch {} Loss {:.4f} Accuracy {:.4f}'.format(epoch + 1, 
                                            train_loss.result(), 
                                            train_accuracy.result()))

    print ('Time taken for 1 epoch: {} secs\n'.format(time.time() - start))

  
  ref,hyp1,hyp2,hyp3,temp = [],[],[],[],[]
  for m,n in zip(videos_test,captions_test):
    translated1,translated2,translated3 = translate(m,False)
    
    hyp1.append(re.sub(r'^\s+|\s+$','',re.sub(r'\.', '', translated1)))
    hyp2.append(re.sub(r'^\s+|\s+$','',re.sub(r'\.', '', translated2)))
    hyp3.append(re.sub(r'^\s+|\s+$','',re.sub(r'\.', '', translated3)))
    temp.append(re.sub(r'^\s+|\s+$','',re.sub(r'\.', '', n)))
    print(n)
    print('\n\n')
  ref= [temp]
    

  #print(hyp)
  #print(ref)
  score_bleu1 = sacrebleu.corpus_bleu(hyp1,ref)
  score_bleu2 = sacrebleu.corpus_bleu(hyp2,ref)
  score_bleu3 = sacrebleu.corpus_bleu(hyp3,ref)
  print('bleu greedy is {}'.format(score_bleu1.score))
  print('bleu bl=1 is {}'.format(score_bleu2.score))
  print('bleu bl=2 is {}'.format(score_bleu3.score))
      
    

  
    
  